{
  "name": "Introduction aux Fragments sous Android",
  "tagline": "",
  "body": "# Introduction aux Fragments sous Android\r\n[Je m'en fiche, je veux aller voir directement l'exercice !](#exercice)\r\n## Origine et définition des Fragments\r\nPour mieux comprendre l’intérêt des Fragments, étudions leur origine. Les\r\nFragments ont été introduits avec la version *Honeycomb 3.0* d’Android (API 11),\r\nversion introduisant le système Android aux tablettes. Et c’est exactement pour\r\nces dernières que les Fragments ont été créés : afin de donner plus de\r\nflexibilité lors de la création d’interfaces utilisateur Android.\r\n\r\nConcrètement, les Fragments donnent la possibilité d’être séparés en plusieurs\r\nécrans sur mobile et d’être combinés sur un seul écran sur tablette, comme\r\nillustré ci-dessous :\r\n\r\n![Figure illustrant l’utilisation de Fragments dans une UI \"Les Fragments dans\r\nune interface mobile et tablette\"](https://github.com/Tydax/m2_android_fragment/blob/master/tutorial/img/01_uifrag.png?raw=true)\r\n\r\nUn **Fragment** représente une partie comportementale et/ou d’interface\r\nutilisateur dans un **Activity**. On pourrait les définir comme une portion\r\nd’**Activity**, vu qu’ils sont obligatoirement liés à une Activity à leur\r\ncréation. Et là où les Fragments présentent un intérêt, c’est qu'ils constituent\r\nde véritables composants réutilisables à travers l’application vu qu’ils peuvent\r\nêtre intégrés comme on le souhaite dans une Activity. C’est cette fonctionnalité\r\nqui fournit la flexibilité recherchée dans leur design.\r\n\r\n## Détails techniques\r\n### Bibliothèque de support\r\nAfin que les appareils tournant sous des versions d'Android antérieure à la 3.0\r\n(ne riez pas, ça existe), il existe une bibliothèque de support intégrée à\r\nAndroid : `android.support.v4.app.Fragment`.\r\n**Faites très très attention !** L'existence de cette bibliothèque peut créer\r\ndes conflits dans votre iDE si vous importez la mauvaise version dans votre\r\nclasse ! Et honnêtement, il n'y a rien de plus frustrant que perdre trente\r\nminutes sur un mauvais import… Donc s'il vous plaît, pensez-y !\r\n\r\n### Classe\r\nÉtant des portions d’Activity, les Fragments possèdent un cycle de vie similaire\r\n. Pour créer un Fragment, il suffit de créer une classe héritant de la classe\r\n`Fragment`. Il existe également des classes filles de `Fragment` utilisables\r\ncomme classe mère :\r\n* `DialogFragment` pour afficher une fenêtre de dialogue ;\r\n* `ListFragment` pour afficher une liste gérée par un adapter, similaire à\r\n`ListActivity` ;\r\n* `PreferenceFragment` pour afficher une liste d’objets `Preference`, similaire\r\nà `PreferenceActivity`.\r\n\r\nPour associer un comportement à des moment-clefs du cycle de vie du Fragment, on\r\nretrouve des méthodes à surcharger similaires celles présentes dans la classe\r\n`Activity`, telles que :\r\n* `onCreate()`, à la création du Fragment ;\r\n* `onCreateView()`, lorsqu’Android dessine l’interface du Fragment ;\r\n* `onPause()` ;\r\n* `onStop()` ;\r\n* `onActivityCreated()`, etc.\r\n\r\n### Layout\r\nReprésentant un élément d’interface utilisateur, on aimerait bien pouvoir lier\r\nun layout à notre Fragment ! Pour cela, pas le choix, on va devoir le faire en\r\nprogrammation, c’est-à-dire directement en Java depuis notre classe Fragment.\r\nRien de bien compliqué, il suffit de créer un fichier layout, par exemple\r\n`exemple_de_fragment.xml`, et depuis la méthode `onCreateView()` de notre\r\nFragment, on inflate la vue et on la retourne :\r\n\r\n```java\r\n@Override\r\npublic View onCreateView(LayoutInflater inflater, ViewGroup container,\r\n                         Bundle savedInstanceState) {\r\n    // Inflate the layout for this fragment\r\n    return inflater.inflate(R.layout.exemple_de_fragment, container, false);\r\n}\r\n```\r\n\r\n### L’intégration d’un fragment au sein d’une Activity\r\nIl est possible d’intégrer un Fragment dans une Activity de deux manières\r\ndifférentes, soit en le déclarant directement dans le layout de l’Activity, soit\r\nà l’ajoutant de manière programmatique.\r\n\r\n#### En configuration\r\nL'avantage principal de déclarer le Fragment dans le fichier .xml est qu'on a\r\nun meilleur aperçu de où il sera placé dans le layout. C'est surtout\r\nintéressant si on a plusieurs Fragments dans un même layout.\r\n\r\nVoici par exemple comment insérer une instance de la classe `ExempleFragment`\r\ndont le nom de classe complet est `fr.lille1.univ.ExempleFragment` :\r\n\r\n```xml\r\n<fragment\r\n  android:name=\"fr.lille1.univ.ExempleFragment\"\r\n  android:id=\"@+id/fragex1\"\r\n  android:layout_width=\"0dp\"\r\n  android:layout_height=\"match_parent\" />\r\n```\r\n\r\nPlutôt clair et simple, non ?\r\n\r\n#### De manière programmatique\r\nAjouter un Fragment de manière programmatique présente l'énorme avantage de\r\npouvoir modifier l'interface durant l'exécution. Il est cependant nécessaire\r\nd'avoir un **ViewGroup** déclaré dans le layout où l'on souhaite ajouter le\r\nFragment.\r\n\r\nL'ajout de Fragment requiert l'utilisation de **FragmentTransaction**, qui\r\nreprésente une action de manipulation de Fragment (ajout, suppression,\r\nremplacement). Voici un exemple où on ajoute notre `ExempleFragment` précédent\r\nà une `ViewGroup` dont l'id est `exemple_container` :\r\n\r\n```java\r\nfinal FragmentManager fragMgr = getFragmentManager();\r\nfinal FragmentTransaction fragTrans = fragMgr.beginTransaction();\r\nfinal ExempleFragment exFrag = new ExempleFragment();\r\nfragTrans.add(R.id.exemple_container, exFrag); // Ajout du Fragment\r\n// On peut faire autant d'opérations sur les Fragments que souhaitées avant de commit\r\nfragTrans.commit(); // On valide les modifications\r\n```\r\n\r\nSous la bibliothèque de support, on doit faire appel à la méthode\r\n`getSupportFragmentManager()`.\r\n\r\n## <a name=\"exercice\"></a>À vous de jouer !\r\nCe TP consiste à implémenter une vue à base de Fragments affichant d'une part\r\nune liste de titres d’albums et d'autre part les détails de l'album sélectionné.\r\nDe façon similaire à l'illustration donnée ci-dessus, on souhaiterait :\r\n* **dans le cas des mobiles**, afficher la liste sur une première Activity, et\r\nafficher les détails sur une autre Activity ;\r\n* **dans le cas des tablettes**, scinder l'écran en deux, avec la liste à gauche\r\net les détails à droite.\r\n\r\nPour des raisons de simplicité (vu que tout le monde n'a pas de tablette),\r\non considérera qu'en basculant son mobile en mode paysage l'affichage sera le\r\nmême que sur tablette.\r\n\r\nLe projet a été créé sur la base de l'Activity “Master/Details flow” qui fournit\r\ndéjà une implémentation fonctionnelle de Fragment et d'Activity. Je l'ai adapté\r\nà notre exemple.\r\n\r\nLa structure est simple : il y a deux Activity (`AlbumListActivity`, affiche\r\nla liste d'albums, et `AlbumDetailActivity`, affiche les détails d'un album).\r\nUn Fragment `AlbumDetailFragment` est défini permettant d'afficher les détails\r\nd'un album.\r\n\r\nEn mode portrait, `AlbumListActivity` affichera la liste d'albums,\r\net cliquer sur l'un ouvrira `AlbumDetailActivity` qui contiendra le Fragment\r\n`AlbumDetailFragment`.\r\n\r\nEn mode paysage, `AlbumListActivity` affichera la liste d'albums et le Fragment\r\n`AlbumDetailFragment` à sa droite. Cliquer sur un album de la liste mettra à\r\njour le Fragment avec les détails de l'album.\r\n\r\nVous aurez deux portions de code très similaires à implémenter.\r\n\r\n1. Dans la méthode `onCreate()` de la classe `AlbumDetailActivity`, vous devez\r\najouter une nouvelle instance d'`AlbumDetailFragment` et l'injecter dans la\r\n`NestedScrollView` qui servira alors de container.\r\n\r\n2. Dans la méthode `onBindViewHolder()` de la classe `AlbumListActivity`, vous\r\nallez devoir *remplacer* le contenu de la vue par une nouvelle instance\r\nd'`AlbumDetailFragment`.\r\n\r\nN'oubliez pas de passer le bundle d'arguments défini via la méthode\r\n`setArguments(Bundle)` de la classe Fragment ! Ce bundle contient l'identifiant\r\nde l'album cliqué.\r\n\r\n**Attention :** j'ai eu la (mauvaise) idée de laisser la compatibilité du projet\r\nà des vieilles versions d'Android, c'est donc la bibliothèque de support qui est\r\nutilisée. Faites bien attention à vos imports et à bien utiliser la méthode\r\n`getSupportFragmentManager()`.\r\n\r\n…\r\n\r\n…\r\n\r\n… Vous vous en sortez ? Non ?\r\nVous pouvez voir la correction sur la branche `correction`.\r\n\r\n## Conclusion\r\nPour résumer, les Fragments sont des portions d'Activity qui peuvent représenter\r\nune partie de comportement et/ou d'interface et qui sont réinjectables selon les\r\nsouhaits du développeur dans une Activity. Les Fragments peuvent sembler un peu\r\nétranges à aborder au début, mais leur utilisation permet une bien plus grande\r\nflexibilité lors de la construction des interfaces sous Android, notamment\r\nlorsque plusieurs plateformes rentrent en compte.\r\n\r\n## Pour aller plus loin\r\nVoici quelques liens, notament vers la documentation d'Android, afin d'avoir des\r\ninformations plus complètes sur les Fragments.\r\n* [EN] [Présentation des Fragments](https://developer.android.com/guide/components/fragments.html)\r\n* [EN] [Building a Dynamic UI with Fragments](https://developer.android.com/training/basics/fragments/index.html)\r\n* [EN] [Communicating with Other Fragments](https://developer.android.com/training/basics/fragments/communicating.html)\r\n\r\n[Retour à l'accueil](https://github.com/Tydax/m2_android_fragment)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}